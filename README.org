#+TITLE: My Vanilla yet powerful Emacs environment
#+AUTHOR: Xichen Zhou
#+OPTIONS: toc:1
#+PROPERTY: header-args :tangle README.el

* Introduction
For years I have been perfecting my Emacs configuration, it is now the
essential part of my digital life. This is my personal configuration but
you may also find it useful to your needs. Feel free to grab some of my
config snippets to work for you.

Here is a list of incomplete features you get from this config set:
- Clean configuration with [[https://github.com/jwiegley/use-package][use-package]]
- Many programming language support: C/C++, Python, typescript, golang, glsl and many others.
- Some of my collected code snippets for different languages.
- Code auto-complete support via eglot and [[https://company-mode.github.io/][Company-mode]].
- Completion framework using [[https://github.com/abo-abo/swiper][Ivy]].
- keybinding look-up with [[https://github.com/justbur/emacs-which-key][which-key]].
- FlySpell support via Hunspell.
- minimal LLM support through [[https://github.com/s-kostyaev/ellama][Ellama]].
- many others.

** Run-time requirement and system setups
Some of the packages requires not only Emacs-Lisp code but also other
binaries to work. Here is the list of binaries required for all the
features.

- Clang installation for LSP back-end.
- Compiler or Interpreter for the targeting programming languages.
- SQLite3 for org-roam.
- Latex installation for =org-latex-preview=
- [[https://github.com/BurntSushi/ripgrep][ripgrep]] for refactoring
  support.
- Hunspell installation for flyspell.
- Ollama for ellama package.

Note that none of those are hard requirements, you will simply lose some
features if you don't have them.

*** Binaries for Windows
On Linux, those run-time requires can be easily satisfied with package managers
like =apt-get= or =dnf install=. On windows, it's another story, for this purpose,
I maintain a [[https://github.com/xeechou/dotemacs-msbin][dotemacs-msbin]] for those dependencies on Windows.

*** Binaries for MacOS
On MacOS binaries can be installed using [[https://brew.sh/][Homebrew]]. You can use the following commands to setup
#+begin_src bash :tangle no
# install emacs
brew tap d12frosted/emacs-plus
#by default install the Emacs29
brew install emacs-plus --with-imagemagick --with-native-comp

# the packages, binuitls may cause troubles on M4 (for windres)
brew install ripgrep aspell ninja binutils gnupg
#for org-downloads
brew install pngpaste
# the fonts
brew install --cask font-iosevka font-iosevka-aile font-fira-sans font-fira-code

# The texlive. For minimal install you can try the basicTex then the additional
# packages
brew install basictex ghostscript imagmagick
#dvipng is required for org-latex-preview
sudo tlmgr update --self && sudo tlmgr install dvipng wrapfig capt-of

# install vterm for aider
brew install libvterm

# install pinentry-mac for auth-info
brew install pinentry-mac

# finally start emacs service, recommand emacs-plus packages
brew services start emacs-plus@30
#+end_src

There are also some [[file:macos.org][adjustment settings]] I made for MacOS, it is totally personal, you do not need to apply to your situation.

* My personal function defines
All my functions are defined with prefix ~my/~.

** File operations
#+begin_src emacs-lisp
(defun my/dotfile-dir ()
  (file-name-directory (or (buffer-file-name) load-file-name)))

(defun my/concat-path (&rest parts)
  (cl-reduce (lambda (a b) (expand-file-name b a)) parts))

(defun my/merge-list-to-list (dst-list src-list)
  (dolist (item src-list) (add-to-list dst-list item)))

(defun my/merge-list-buffer-local (dst-list src-list)
  ;;not that dst-list need to be quoted
  (make-variable-buffer-local dst-list)
  (my/merge-list-to-list dst-list src-list))

(defun my/filename ()
  "Copy the filename of the current buffer."
  (interactive)
  (kill-new (buffer-name (window-buffer (minibuffer-selected-window)))))

(defun my/full-path ()
  "Copy the full path of the current buffer."
  (interactive)
  (kill-new (buffer-file-name (window-buffer (minibuffer-selected-window)))))

(defun my/test-port-open (host port)
  "Test if a TCP PORT at HOST is open."
  (condition-case nil
      (progn
        (let ((stream (open-network-stream "test-stream" nil host port)))
          (delete-process stream)
          t))
    (error nil)))

#+end_src
** Reload buffer for ~.dir-locals.el~

Sometimes you need to modify ~.dir-locals.el~ while editing. Following two functions helps you reload current buffer with modified ~.dir-locals.el~
#+begin_src emacs-lisp
  (defun my/reload-dir-locals-for-current-buffer ()
    "reload dir locals for the current buffer"
    (interactive)
    (let ((enable-local-variables :all))
      (hack-dir-local-variables-non-file-buffer)))

  (defun my/reload-dir-locals-for-all-buffer-in-this-directory ()
    "For every buffer with the same `default-directory` as the
  current buffer's, reload dir-locals."
    (interactive)
    (let ((dir default-directory))
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when (equal default-directory dir)
            (my/reload-dir-locals-for-current-buffer))))))  
#+end_src

** Proxies functions
Emacs inherits your proxy ~ENV~ such as ~http_proxy~ and ~https_proxy~. I have two functions when you need to toggle on/off proxies.
#+begin_src emacs-lisp
  (defun my/disable-proxy ()
    "Disable the proxy used in emacs"
    (interactive)
    (setq url-proxy-services
          `(("http" . nil)
            ("https" . nil)
            ("no_proxy" . ,(getenv "no_proxy"))))
    ;;backup the proxy settings
    (setenv "http_proxy_backup" (getenv "http_proxy"))
    (setenv "https_proxy_backup" (getenv "https_proxy"))
    (setenv "ftp_proxy_backup" (getenv "ftp_proxy"))
    ;;clean up the proxy settings
    (setenv "http_proxy" nil)
    (setenv "https_proxy" nil)
    (setenv "ftp_proxy" nil)
    )

  (defun my/enable-proxy ()
    "Re-enable proxy from environment variables"
    (interactive)
    (setenv "http_proxy" (getenv "http_proxy_backup"))
    (setenv "https_proxy" (getenv "https_proxy_backup"))
    (setenv "ftp_proxy" (getenv "ftp_proxy_backup"))

    (setq url-proxy-services
          `(("http" . ,(getenv "http_proxy"))
            ("https" . ,(getenv "https_proxy"))
            ("ftp_proxy" . ,(getenv "ftp_proxy"))
            ("no_proxy" . ,(getenv "no_proxy"))))
    )
  ;;get the current proxy
  (defun my/has-or-get-proxy()
    (or (getenv "https_proxy")
        (getenv "http_proxy")))
#+end_src

** Generate UUIDs
#+begin_src emacs-lisp
  (use-package uuidgen :ensure t :defer t :pin melpa
    :init
    (defun my/insert-uuid ()
      "insert UUID at the point"
      (interactive)
      (insert (uuidgen-4)))
    )
#+end_src
** per-device settings
#+begin_src emacs-lisp
  (use-package perdev :load-path "lisp")
#+end_src

** Downloading transcript from YouTube
This tool can be used by LLM
#+begin_src emacs-lisp
(use-package ytb-sub-dl
  :load-path "lisp"
  :when (executable-find "yt-dlp")
  :commands (ytb-sub-dl-insert-transcript))
#+end_src


* Global settings
menu bar configuration. I disable tool bar and scroll bar for a minimalist look. Also, disable the bell using ~visbible-bell~ and enable some global modes.

#+begin_src emacs-lisp
(display-time)
(when (or (display-graphic-p) (daemonp))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq visible-bell 1))
;;enabled global modes
(save-place-mode 1)
(global-auto-revert-mode t)
(column-number-mode 1)
(delete-selection-mode 1)

;;default to text mode
(setq-default major-mode 'text-mode)
;;displaying line numbers
(add-hook 'prog-mode-hook 'display-line-numbers-mode)

;;highlight current line
(add-hook 'prog-mode-hook 'hl-line-mode)
(diminish 'hl-line-mode)

;; NOTE: do not Ignore case when completing file names, cause very annoying bugs in lldb that it cannot resolve the symbols.
(setq read-file-name-completion-ignore-case nil)
#+end_src

** Setup the default encoding environment
#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)  
#+end_src

** Backup files
copied from emacswiki
#+begin_src emacs-lisp
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.saves/"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+end_src

** Recent files
#+begin_src emacs-lisp
(use-package recentf
  :init
  (setq
    recentf-save-file  (expand-file-name "recentf" user-emacs-directory)
    recentf-max-saved-items 10000
    recentf-max-menu-items 5000
    )
  (recentf-mode 1)
  (run-at-time nil (* 5 60) 'recentf-save-list))
#+end_src

** [[https://github.com/baudtack/pomodoro.el][pomodoro.el]]
#+begin_src emacs-lisp
  (use-package pomodoro :defer t
    :vc (:fetcher github :repo "baudtack/pomodoro.el")
    :commands pomodoro-start
    :custom
    (pomodoro-work-start-sound (expand-file-name "assets/stop1.mp3" (my/dotfile-dir)))
    (pomodoro-break-start-sound (expand-file-name "assets/rest.mp3" (my/dotfile-dir)))
    :config
    (pomodoro-add-to-mode-line)
    (cond ((executable-find "mpg123") (setq pomodoro-sound-player "mpg123"))
          ((executable-find "mpv") (setq pomodoro-sound-player "mpv"))
          ((executable-find "vlc") (setq pomodoro-sound-player "vlc"))
          ((executable-find "mplayer") (setq pomodoro-sound-player "mplayer"))
          ((executable-find "cmus") (setq pomodoro-sound-player "cmus"))
          ;;if no player found, just skip it
          (t (setq pomodoro-play-sounds nil))))
#+end_src

** auth-info

#+begin_src emacs-lisp
;; also set allow-loopback-entry in gpg-agent.conf and gpgconf --reload gpg-agent
;;
;; this means clients like Emacs can get the password in their own way and push to gpg
;; for this to work with Emacs, set epa-pinentry-mode to 'loopback in Emacs
(setq epg-pinentry-mode 'loopback)
#+end_src

* Org mode settings
** Convenience functions
#+begin_src emacs-lisp
  (require 'org-funcs)
  (defun my/org-dir-set (dir)
    (and dir (not (string= dir "")) (file-exists-p dir)))
  (defun my/org-file (path)
    (expand-file-name path (perdev-get-evaluated-value
                            'my/default-org-dir
                            org-directory ;;default value
                            org-directory ;;argument
                            )))
#+end_src
** Org Mode
#+begin_src emacs-lisp :noweb yes
(use-package org :ensure t :defer t
  :mode (("\\.org$" . org-mode))
  :commands org-capture
  :custom
  (org-log-done  'time)
  (org-clock-persist 'history)
  (org-adapt-indentation nil)
  (org-image-actual-width 300) ;;set to 300px
  ;;setup the column, this max length for the first level we can go, maybe we
  ;;can somehow calculate it?
  (org-tags-column -54)
  (org-image-actual-width 600)
  ;;getting rid of leading white-space in code indentation
  (org-edit-src-content-indentation 0)
  ;; this removes the leading white space when you done editing
  (org-src-preserve-indentation nil)

  ;;faces
  (org-todo-keywords '((sequence "TODO" "DOIN" "|" "DONE" "PEND" "CANC")))

  :hook
  ((org-after-todo-statistics . org-funcs-summary-todo)
   (org-checkbox-statistics . org-funcs-checkbox-todo)
   (org-mode . org-funcs-define-faces))
  ;; I am not sure this global key setting is good or not, capture stuff
  ;; globally is great
  :bind (("C-c o a"   . org-agenda)
         ("C-c o c"   . org-capture)
         <<ORG_KEYS>>
         :map org-mode-map
         ("C-c o C-w"  . org-refile)
         ("M-<left>"  . org-metaleft)
         ("M-<right>" . org-metaright)
         ("M-<up>"    . org-metaup)
         ("M-<down>"  . org-metadown))
  :init
  <<ORG_SETUP>>

  ;; enable images
  (setq org-startup-with-inline-images t)

  ;;activate babel languages
  :config
  ;;note files
  <<ORG_NOTE_AGENDA>>
  ;;latex setup
  <<ORG_LATEX>>

  (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file)
  (org-clock-persistence-insinuate)
  ;; I just use PEND to define stuck projects.
  (setq org-stuck-projects
        '("/-DONE-CANC" ("DOIN" "TODO") nil ""))
  ;;capture templates

  (setq org-capture-templates
        `(
          <<ORG_CAPTURE>>            
          ))
  (org-funcs-load-babel-compiler))
#+end_src
*** Org directory setup
org-directory has to have trailing "/"  
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_SETUP
  (setq org-directory (if (my/org-dir-set (getenv "ORG_DIR"))
                          (getenv "ORG_DIR")
                        "~/org/")) 
#+end_src

*** Agenda setup
I divide my agenda files to the following:
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_NOTE_AGENDA
  (setq org-default-notes-file
        (my/concat-path org-directory "notes.org"))

  (setq org-agenda-files (perdev-get-evaluated-value
                          'my/org-agenda-files '() org-directory))
#+end_src

Show unplanned tasks in global TODO list.
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_NOTE_AGENDA
  (setq org-deadline-warning-days 7)
  ;;ignore what's already done
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  ;;ignore todo items that has dead lines since they will appear in agenda.
  (setq org-agenda-todo-ignore-deadlines 'near)
  (setq org-agenda-todo-ignore-scheduled 'all)
  ;;avoid duplicates deadlines in agenda
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  ;;this works when you place a schedule, so it will not duplicate
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
#+end_src

log the agenda states into drawer, instead of insert inside org files.
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_NOTE_AGENDA
    (setq org-log-into-drawer t)    
#+end_src

It will prevent from inserting a state directly under headings.
- State "DONE"       from "DOIN"       [2024-02-26 Mon 08:50]
Instead it will be inside a ~:LOGBOOK:~

*** Capture templates
**** Capture tasks in ~misc.org~ to sort later
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_CAPTURE
  ;; misc tasks, moving coding or writing later?
  ("m" "Miscs" entry
               (file+headline ,(my/org-file "miscs.org") "Captures")
               "** TODO %?\n%i\n  %a" :prepend t)
#+end_src

**** Capture some ideas in ~thoughts.org~
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_CAPTURE
  ;; my ideas
  ("s" "Thoughts" entry
   (file+headline ,(my/org-file "thoughts.org") "Ideas")
   "* %?\n %i\n \n\n"
   :prepend t)
#+end_src

**** Something to read.
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_CAPTURE
  ;; Learning items
  ("r" "Reading" entry
   (file+headline ,(my/org-file "reading.org") "Articles")
   "** TODO %?\n%i\n %^L\n \n"
   :prepend t) ;;why the linebreak didn't work?
#+end_src

**** Reviews.
#+begin_src  emacs-lisp :tangle no :noweb-ref ORG_CAPTURE
  ("p" "Review+Planning" entry
   (file+headline ,(my/org-file "goals-habits.org") "Review+TODOs+Plan+Journal")
   "**** On %t\n***** Planned:\n\n %i \n "
   :prepend t)
#+end_src

**** Today
The template
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_CAPTURE
("t" "Today" entry
 (file+headline ,(my/org-file "writing.org") "Todays")
 "** TODO %? \n SCHEDULED: %t\n%i"
 :prepend t)
#+end_src

Then we use special key bindings for going todays.
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_SETUP
(defun my/org-capture-today () (interactive) (org-capture nil "t"))
(defun my/org-goto-today () (interactive) (org-capture-goto-target "t"))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ORG_KEYS
("C-c o t" . my/org-capture-today)
("C-c o T" . my/org-goto-today)
#+end_src

*** Latex setup in org
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_LATEX
(cond
 ;; 1: If we have dvipng, use this by default
 ((and (executable-find "dvipng") (executable-find "latex")) 
  (setq org-preview-latex-default-process 'dvipng))
 
 ;; 2: see if new magick is available
 ;;
 ;; old convert command is considered deprecated, in either case, you need the
 ;; ghostscript
 ((and (executable-find "magick") (executable-find "pdflatex") (executable-find "gs"))
  ;; add new item to associations
  (prog2
    (when (not (assoc 'magick org-preview-latex-process-alist))
      (push '(magick
              :programs ("latex" "magick")
              :description "pdf > png"
              :message "you need to install the programs: latex and imagemagick."
              :image-input-type "pdf"
              :image-output-type "png"
              :image-size-adjust (1.0 . 1.0)
              :latex-compiler ("pdflatex -interaction nonstopmode -output-directory %o %f")
              :image-converter
              ("magick convert -density %D -trim -antialias %f -quality 100 %O"))
            org-preview-latex-process-alist))
      (setq org-preview-latex-default-process 'magick)))

 ;; 3:  see if old convert is available
 ((and (executable-find "convert") (executable-find "pdflatex") (executable-find "gs"))
  (setq org-preview-latex-default-process 'imagemagick)))

(setq org-preview-latex-image-directory
      (my/concat-path temporary-file-directory
                     "ltximg/"))
;;set latex preview scale
(setq org-format-latex-options (plist-put
                                org-format-latex-options
                                :scale (perdev-get-value 'my/org-latex-scale1 1.0)))
#+end_src

On archlinux, you need to install
- texlive-basic
- texlive-bin
- texlive-latex
- texlive-lateextra
- texlive-latexrecommanded
- texlive-pictures,
- texlive-plangeneric

** Org mode appearance setup
*** mixed pitch mode
allows you to use fixed pitch (for code) and variable pitch (everything else) *IN THE BUFFER*
#+begin_src emacs-lisp
(use-package mixed-pitch :ensure t :defer t
  :hook
  (org-mode . mixed-pitch-mode)
  :custom
  (mixed-pitch-variable-pitch-cursor 'box))
#+end_src

*** org-modern package

#+begin_src emacs-lisp :noweb yes
(use-package org-modern :ensure t :after org
  :hook
  (org-mode . org-modern-mode)
  (org-agenda-finalize . org-modern-agenda)
  :custom
  <<ORG_MODERN_STAR>>

  (org-hide-emphasis-markers t)
  (line-spaceing 0.3)
  (org-fontify-done-headline t)
  
  :config
  (set-face-attribute 'org-modern-symbol nil
                      :family (perdev-get-value 'my/org-modern-symbol-font "Iosevka"))

  (custom-theme-set-faces
   'user
   '(org-block ((t (:inherit fixed-pitch))))
   '(org-code ((t (:inherit (shadow fixed-pitch)))))
   '(org-document-info ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-link ((t (:foreground "royal blue" :underline t))))
   '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
   '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
  )
#+end_src

*** About the stars
"*" are the leading character for each org-mode block. Org modern has a few configurations with it

#+begin_src emacs-lisp :tangle no :noweb-ref ORG_MODERN_STAR
;;org-modern actually don't like indent mode
(org-startup-indented t)

;; 'replace using ◉○◈◇✳. 'fold use "▶", the bug here is that it does not hide the line-prefix.. So we just disable to org-modern-star
(org-modern-star nil)

;; optionally you will be able to hide ORIGINAL * or not, leading means to hide the leading stars
(org-modern-hide-stars nil)
#+end_src


** Org Roam
Setting the correct org-roam connector based on version. Emacs-29, which uses emacs builtin sqlite library, prior to that, it uses sqlite utilities from OS.
#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_SQLITE
  (if (version< emacs-version "29.0")
      (setq org-roam-database-connector 'sqlite)
    (setq org-roam-database-connector 'sqlite-builtin))  
#+end_src

#+begin_src emacs-lisp :noweb yes
(use-package org-roam :ensure t :after org :defer t
  :init
  <<ROAM_SQLITE>>
  ;; disable org-roam warning
  (setq org-roam-v2-ack t)
  (defun my/roam-dir () (expand-file-name "pages" org-directory))
  <<ROAM_VISIT>>

  :custom
  ;; for some reason the (my/roam-dir) is not loaded correctly here
  (org-roam-directory (expand-file-name "pages" org-directory))
  (org-roam-completion-everywhere t)
  (org-roam-db-update-on-save t)
  ;;template for v2
  (org-roam-capture-templates
   '(
     <<ROAM_CAPTURES>>
     ))
  ;; displaying tags along with title for org roam
  (org-roam-node-display-template
   (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))

  :bind  (("C-c o f" . org-roam-node-find)
          ("C-c o C" . org-roam-capture)
          ("C-c o i" . org-roam-node-insert)
          ("C-c o g" . org-roam-ui-mode)

          :map org-mode-map
          ("C-c o r" . org-roam-buffer-toggle) ;;toggle-back-links
          :map org-roam-mode-map
          ;;NOTE alternatively, use C-u RET to visit in other window
          ("RET" . my/roam-visit))
  :config
  ;;start db sync automatically, also you are able to refresh back link buffer,
  ;;alternatively you hook org-roam-db-auto-sync-mode to org-roam-mode
  (org-roam-db-autosync-enable)

  ;;excluding org-roam-dailes from roam-database
  ;; configure org-roam-buffer
  <<ROAM_CONFIG>>
  )
#+end_src

***  org-roam dailies

#+begin_src emacs-lisp
(use-package org-roam-dailies
  :ensure nil ;; Do not enable, it is part of org-roam
  :init
  (define-prefix-command 'my/org-roam-dailies-map)  
  :bind
  (("C-c o d" . my/org-roam-dailies-map)
   :map my/org-roam-dailies-map
  ;; NOTE that Do not confuse org-roam-dailies capture with daily task-captures
  ("T" . org-roam-dailies-capture-today)
  ("t" . org-roam-dailies-goto-today)
  ("n" . org-roam-dailies-goto-date)
  ("y" . org-roam-dailies-goto-yesterday)))
#+end_src

***  Also, excluding org-roam-dailies from captures
#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_CONFIG
(setq org-roam-db-node-include-function
      (lambda ()
        (let ((path (buffer-file-name (buffer-base-buffer)))
              ;; org-roam-dailies-directory is a relative path
              (dailies-dir (expand-file-name org-roam-dailies-directory
                                             org-roam-directory)))
          (not (file-in-directory-p path dailies-dir)))))
#+end_src


*** Roam templates
Mostly I only use default template
#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_CAPTURES
       ("d" "default" plain "%?"
        :if-new (file+head "${slug}.org"
                           "#+title: ${title}\n#+filetags: %^{org-roam-tags}\n#+created: %u\n")
        :unnarrowed t
        :jump-to-captured t)  
#+end_src

Optionally, create a note from clipboard.
#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_CAPTURES
       ("l" "clipboard" plain (function org-roam--capture-get-point)
        "%c"
        :file-name "${slug}"
        :head "#+title: ${title}\n#+created: %u\n#+last_modified: %U\n\
  ,#+ROAM_TAGS: %?\n"
        :unnarrowed t
        :prepend t
        :jump-to-captured t)  
#+end_src
*** Roam buffer
visiting roam pages using different other window. It's most case what you want.
#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_VISIT
  (defun my/roam-visit () (interactive) (org-roam-node-visit
                                         (org-roam-node-at-point) 'other-window))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ROAM_CONFIG
  (add-to-list 'display-buffer-alist
               '("\\*org-roam\\*"
                 (display-buffer-in-direction)
                 (display-buffer-in-previous-window)
                 (direction . right)
                 (window-width . 0.33)
                 (window-height . fit-window-to-buffer)))
#+end_src

** Org roam UI
#+begin_src emacs-lisp
  (use-package org-roam-ui :ensure t :after org-roam
    :diminish org-roam-ui-mode
    :config
    (setq org-roam-ui-sync-theme nil
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

#+end_src
** Org utilities
*** Clipboard
#+begin_src emacs-lisp

  (use-package org-cliplink :ensure t :after org
    :bind (:map org-mode-map
                ("C-c C-p i" . org-cliplink)
                ("C-c C-p l" . org-store-link)))
#+end_src

*** Org download
#+begin_src emacs-lisp
;; org-download;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package org-download :ensure t :after org
  :hook
  ;;this hook will run at-startup because of org-clock, and we do not have a
  ;;(buffer-file-name) then, so we need to error check it
  (org-mode . (lambda ()
                ;;download into the "img dir of current org file directory"
                (when (buffer-file-name)
                  (let ((currdir (file-name-directory (buffer-file-name))))
                    (set (make-local-variable 'org-download-image-dir)
                         (expand-file-name "imgs/" currdir))))))
  :bind (:map org-mode-map
              ("C-c C-p s" . org-download-screenshot)
              ("C-c C-p y" . org-download-yank)
              ("C-c C-p c" . org-download-clipboard)))

#+end_src
*** Org Ref
using the IVY framework 
#+begin_src emacs-lisp
  (use-package ivy-bibtex :ensure t :after org
    :init
    (setq bibtex-completion-bibliography `,(my/org-file "bib/references.bib")))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; org-ref
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (use-package org-ref :ensure t :after org
    :init
    (require 'org-ref-arxiv)
    (require 'org-ref-scopus)
    (require 'org-ref-wos)
    (require 'org-ref-ivy)
    (setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body
          org-ref-insert-cite-function 'org-ref-cite-insert-ivy
          org-ref-insert-label-function 'org-ref-insert-label-link
          org-ref-insert-ref-function 'org-ref-insert-ref-link
          org-ref-cite-onclick-function (lambda (_) (org-ref-citation-hydra/body)))
    ;; setup auto generating bibtex keys
    (require 'bibtex)
    (setq bibtex-autokey-year-length 4
          bibtex-autokey-name-year-separator "-"
          bibtex-autokey-year-title-separator "-"
          bibtex-autokey-titleword-separator "-"
          bibtex-autokey-titlewords 2
          bibtex-autokey-titlewords-stretch 1
          bibtex-autokey-titleword-length 5)
    ;; export to pdf with bibtex
    ;;this is when you don't have latexmk
    (setq org-latex-pdf-process
          (if (executable-find "latexmk")
              ;;when you have latexmk
              (list "latexmk -shell-escape -bibtex -f -pdf %f")
            ;;when you don't have latexmk
            '("pdflatex -interaction nonstopmode -output-directory %o %f"
              "bibtex %b" ;;using bibtex here, or you can use biber
              "pdflatex -interaction nonstopmode -output-directory %o %f"
              "pdflatex -interaction nonstopmode -output-directory %o %f")))

    :bind (:map org-mode-map
                ("C-c [" . org-ref-insert-link-hydra/body)
                ("C-c ]" . org-ref-insert-link))
    )

#+end_src
** Org Contrib
#+begin_src emacs-lisp
  (use-package org-contrib :ensure t :after org
    :init
    (require 'ox-groff))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; disabled-config
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; My synchronizer
  ;; (use-package org-msync :load-path "lisp/"
  ;;   :hook ((org-mode . org-msync-after-save-hook)
  ;; 	 (auto-save . org-msync-auto-save-hook))
  ;;   :custom
  ;;   (org-msync-local-dir org-directory)
  ;;   (org-msync-remote-dir "~/Documents/org-remote/")
  ;;   )
#+end_src

** Org CV
The [[https://titan-c.gitlab.io/org-cv/][Org CV]] package helps manages the curriculum-vitae easily. The other custom option is following [[https://www.aidanscannell.com/post/org-mode-resume/][Aidan Scannell's post]].

#+begin_src emacs-lisp
  (use-package ox-moderncv ;;TODO this is an exception to defer?
    :vc (:fetcher github :repo "Titan-C/org-cv")
    :init (require 'ox-moderncv))
#+end_src

** Org Jira
Adding Jira tickets to your Calendar
#+begin_src emacs-lisp
(use-package org-jira
  :when (getenv "ORG_JIRA_URL")
  :ensure t :after org :pin melpa
  :commands (org-jira-get-issues)
  :bind-keymap ("C-c o j" . org-jira-entry-mode-map)
  :bind (:map org-jira-entry-mode-map
	      ("ig" . org-jira-get-issues)
	      ("ih" . org-jira-get-issues-headonly)
	      ("iw" . org-jira-progress-issue)
	      ("in" . org-jira-progress-issue-next))
  :config
  (setq org-jira-working-dir (expand-file-name ".org-jira" org-directory))
  (unless (file-exists-p org-jira-working-dir)
      (make-directory org-jira-working-dir))
  ;;jiralib.el is part of the package.
  (setq jiralib-url (getenv "ORG_JIRA_URL"))
  (setq jiralib-token
    (cons "Authorization"
          (concat "Bearer " (auth-source-pick-first-password
                             :host (getenv "ORG_JIRA_URL")))))

  ;; adding the files to org-agenda-files
  (setq org-agenda-files
	(append org-agenda-files (directory-files-recursively org-jira-working-dir "\\.org$")))

  ;; setup the workflow
  (defconst org-jira-progress-issue-flow
    '(("open" . "Ready for Development")
       ("Ready for Development" . "In Progress")
       ("In Progress" . "Closed")
       ("Closed" . "Reopened")))
)
#+end_src

** [[https://github.com/alphapapa/org-web-tools][org-web-tools]]
awesome package to convert web package into a org buffer/or entries.
#+begin_src emacs-lisp
(use-package org-web-tools :pin melpa :after org :ensure t :defer t
  :bind
  (("C-c o wr" . org-web-tools-read-url-as-org)
   :map org-mode-map
   ("C-c o wi" . org-web-tools-insert-web-page-as-entry)))
#+end_src

** [[https://github.com/alphapapa/org-ql][org-ql]] is a much powerful query tool for org mode
Note that ~org-ql-find~ [[https://github.com/alphapapa/org-ql/issues/284][does not work with ivy]], thus I switched to vertico+consult+embark now.

#+begin_src emacs-lisp
(use-package org-ql
  :ensure t :after org :pin melpa
  :after org)
#+end_src

*** Key bindings
#+begin_src emacs-lisp :tangle no :noweb-ref ORG_KEYS
("C-c o v" . org-ql-view)
("C-c o s" . org-ql-search)
#+end_src

* Editing
** Line operations 
Define a backward kill a line:
#+begin_src emacs-lisp
  (defun my/backward-kill-line (arg)
    "Kill ARG line backwards"
    (interactive "p")
    (kill-line (- 1 arg)))
  (define-key prog-mode-map (kbd "C-c u") 'my/backward-kill-line)
#+end_src

Copy a line:
#+begin_src emacs-lisp
(defun my/copy-line ()
  "copy current line, from the first character that is not \t or
  ' ', to the last of that line, this feature is from vim.
  Case to use this feature:
  - repeat similar lines in the code.
  "
  (interactive)
  (save-excursion
    (back-to-indentation)
    (let* ((beg (point))
	   (end (line-end-position))
	   (mystr (buffer-substring beg end)))
      (kill-ring-save beg end)
      (message "%s" mystr)))
  ;;This is silly, find a way to print out last-kill.
  )

(define-key prog-mode-map (kbd "C-c C-k") 'my/copy-line)
#+end_src

move line up and down:
#+begin_src emacs-lisp
(defmacro save-column (&rest body)
  `(let ((column (current-column)))
     (unwind-protect
         (progn ,@body)
       (move-to-column column))))
(put 'save-column 'lisp-indent-function 0)

(defun my/move-line-up ()
  (interactive)
  (save-column
    (transpose-lines 1)
    (forward-line -2)))

(defun my/move-line-down ()
  (interactive)
  (save-column
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)))

(define-key prog-mode-map (kbd "M-<up>") 'my/move-line-up)
(define-key prog-mode-map (kbd "M-<down>") 'my/move-line-down)  
#+end_src

** Moving in the mark ring
backward-forward package helps us jump back-forward in the mark ring.
#+begin_src emacs-lisp
  (use-package backward-forward :ensure t
    :demand
    :config
    (backward-forward-mode t)
    :bind (:map backward-forward-mode-map
                ("<C-left>" . nil)
                ("<C-right>" . nil)
                ("C-c C-<left>" . backward-forward-previous-location)
                ("C-c C-<right>" . backward-forward-next-location)
                ("<mouse-8>" . backward-forward-previous-location)
                ("<mouse-9>" . backward-forward-next-location)))
#+end_src

** Window operations
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x <up>") 'windmove-up)
  (global-set-key (kbd "C-x <down>") 'windmove-down)
  (global-set-key (kbd "C-x <left>") 'windmove-left)
  (global-set-key (kbd "C-x <right>") 'windmove-right)
#+end_src

winner mode has two default keybinding
- "C-c left" : for ~winner-undo~
- "C-c right" : for ~winner-redo~
#+begin_src emacs-lisp
(use-package winner :defer t :ensure t
  :diminish winner-mode
  :hook ((prog-mode text-mode) . winner-mode))
#+end_src

** Rectangle editing
#+begin_src emacs-lisp
  (global-set-key (kbd  "\C-x r i") 'string-insert-rectangle)  
#+end_src

** Mini-buffer with Vertico
*** vertico enhancements
#+begin_src emacs-lisp
(use-package vertico :ensure t
  :diminish vertico-mode
  :custom
  (vertico-count 20)  ;; limit to a fixed size
  (vertico-cycle t)
  :hook
  (after-init . vertico-mode)
  :bind (:map vertico-map
    ;; Use page-up/down to scroll vertico buffer, like ivy does by default.
    ("<prior>" . 'vertico-scroll-down)
    ("<next>"  . 'vertico-scroll-up))
  )
(use-package vertico-directory
  :after vertico
  :ensure nil  ;; no need to install, it comes with vertico
  :bind (:map vertico-map
    ("DEL" . vertico-directory-delete-char)))  
#+end_src

*** marginalia mode provides more contextual information for mini buffer
#+begin_src emacs-lisp
(use-package marginalia :ensure t
  :hook (vertico-mode . marginalia-mode))
#+end_src

*** Orderless provides fuzzing matching
#+begin_src emacs-lisp
(use-package orderless :ensure t
  :custom
  ;; Activate orderless completion
  (completion-styles '(orderless basic))
  ;; Enable partial completion for file wildcard support
  (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Consult provides enhanced commands
#+begin_src emacs-lisp
(use-package consult :ensure t
  :bind
  (;;most basics
   ("C-x b"   . consult-buffer)
   ("C-x C-f" . find-file)
   ("M-x"     . execute-extended-command)
   ("C-x t"   . consult-imenu)
   ("C-c y"   . consult-yank-pop)
   ("C-s"     . isearch-forward)
   ("C-r"     . isearch-backward)
   ;; for git setup
   ("C-c g"   . consult-grep)
   ("C-c j"   . consult-git-grep)
   ("C-c r"   . consult-ripgrep)
   ("C-c l"   . consult-line)   
   ;; in consult-line, we simply get a history in previous search by press
   ;; ctrl-s again. This is not a full replacement for swiper but it can reduce
   ;; quite bit of typing.
   ;; :map minibuffer-local-map
   ;; ("C-s"     . (lambda () (interactive) (insert (car consult--line-history))))
   ))

#+end_src

*** Embark Allows you perform actions in mini-buffer directly
#+begin_src emacs-lisp
(use-package embark :ensure t
  :bind
  (("C-."   . embark-act)       ;; Begin the embark process
   ("C-;"   . embark-dwim)      ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :config
  (use-package embark-consult :ensure t))
#+end_src

** Spell check
the excellent fly-spell to correct my common typing mistakes.
#+begin_src emacs-lisp
  (use-package flyspell
    :if (or (executable-find "aspell")
            (executable-find "hunspell")
            (executable-find "ispell"))
    :defer t
    :hook ((prog-mode . flyspell-prog-mode)
           (text-mode . flyspell-mode) ;;for markdown, org, nxml
           ;;also disable it for specific mode
           (change-log-mode . (turn-off-flyspell)))
    :init
    ;;for flyspell to work, you need to set LANG first
    ;; on windows, getenv has strange behavior, getenv-internal seems to work correctly.
    ;; (when (not (getenv-internal "LANG" initial-environment))
    (setenv "LANG" "en_US")
    ;; priotize aspell over hunspell For Linux and Mac
    :custom  (ispell-program-name (or (executable-find "aspell")
                                      (executable-find "hunspell")
                                      (executable-find "ispell")))
    ;;:config
    ;;TODO flyspell language-tool
    )  
#+end_src

Fly-spell correct: [[*Mini-buffer with Vertico][Vertico]] uses default ~completing-read~ interface, use shortcut key ~@s, @a, @p or @k~ to trigger the actions.
#+begin_src emacs-lisp
;; correcting word and save it to personal dictionary
(use-package flyspell-correct :ensure t :after flyspell
  :bind (:map flyspell-mode-map ("C-c ;" . flyspell-correct-wrapper)))
#+end_src

** isearch
*** Minor adjustment from Protesilaos Stavrou
#+begin_src emacs-lisp
(defun my/isearch-mark-and-exit ()
  "Mark the current search string. Can be used as building block for more
complex chain."
  (interactive)
  (push-mark isearch-other-end t 'activate)
  (setq deactivate-mark nil)
  (isearch-done))

;;press backspace to delete all mis-typings
(defun my/isearch-remove-failed-part-or-last-char ()
  "Remove failed part of search string, or last char if successful. 
Do nothing if search string is empty to start with."
  (interactive)
  (if (equal isearch-string "")
      (isearch-update)
    (if isearch-success
	(isearch-delete-char)
      (while (isearch-fail-pos (isearch-pop-state)))
    (isearch-update))))
#+end_src
*** isearch the marked regions
#+begin_src emacs-lisp
(defun my/isearch-region (&optional not-regexp no-recursive-edit)
  "If a region is active, make this the isearch default search pattern."
  (interactive "P\np")
  (when (use-region-p)
    (let ((search (buffer-substring-no-properties
		   (region-beginning)
		   (region-end))))
      (message "stribb/ir: %s %d %d" search (region-beginning) (region-end))
      (setq deactivate-mark t)
      (isearch-yank-string search))))

(advice-add 'isearch-forward-regexp :after 'my/isearch-region)
(advice-add 'isearch-forward :after 'my/isearch-region)
(advice-add 'isearch-backward-regexp :after 'my/isearch-region)
(advice-add 'isearch-backward :after 'my/isearch-region)
#+end_src

*** isearch transient menu
#+begin_src emacs-lisp
(use-package transient-isearch
  :load-path "lisp"
  :bind (:map
         isearch-mode-map
	 ("DEL" . my/isearch-remove-failed-part-or-last-char)
	 ("C-SPC" . my/isearch-mark-and-exit)
	 ;;(M-s . isearch-common-prefix) ;;very powerful
         ("M-/" . transient-isearch-menu)))
#+end_src

* Keybindings
I tried to keep my keybindings intent and avoid conflicts. Right now there are too many packages fight for ~C-c~.

** [[*Org mode settings][org mode]] keys
org mode keys (especially globally bound keys) starts with ~(C-c o)~

** [[*Eglot mode][Eglot]] key bindings
There are currently two keybindings
- ~C-c R~ :: ~eglot-rename~
- ~C-c H~ :: ~eldoc~

** AI key-bindings
AI related tools starts with ~(C-c i)~
  
* Appearance Settings
** Themes
I have tried a few themes, not satisfied with most of them. Either the contrast is too high, or they are plain ugly. Among them, I like these themes.
- [[https://github.com/nashamri/spacemacs-theme][spacemacs-theme]] : a well designed theme can be used for long time.
- [[https://github.com/waymondo/apropospriate-theme][apropospriate-theme]] : low contrast yet colorful.
- [[https://github.com/protesilaos/modus-themes][modus-themes]]: *current choice*. I like the tinted version of the theme, however I have to disable defer loading to make it work.

#+begin_src emacs-lisp
  (use-package modus-themes
    ;; TODO have to disable defer to get circadian to work
    :ensure t
    :init
    (setq modus-themes-mixed-fonts t)
    (setq modus-themes-common-palette-overrides
          `(
            ;; From the section "Make the mode line borderless"
            (border-mode-line-active unspecified)
            (border-mode-line-inactive unspecified))))  
#+end_src

Now I setup my desired theme here
#+begin_src emacs-lisp :tangle no :noweb-ref THEME
  (setq appr-dark-theme-name 'modus-vivendi-tinted)
  (setq appr-light-theme-name 'modus-operandi-tinted)
  (setq appr-dark-theme-hour 17)
  (setq appr-light-theme-hour 8)
#+end_src

My setup uses ~run-with-timer~ every hour to check the if it's time to change the theme, so it may not change the theme at desired time. *NOTE*: Originally I was using [[https://github.com/guidoschmidt/circadian.el][circadian.el]] but unfortunately that package has misuse of ~run-at-time~ that leads to heavy CPU spikes. See the [[https://github.com/guidoschmidt/circadian.el/issues/28][issue]] for details. I would need to fix that bug if want to switch back to circadian.

** Ligature and font settings
[[https://github.com/mickeynp/ligature.el][ligature]] is a typographical method to combine two or more glyphs or letters  to form a single glyph.

#+begin_src emacs-lisp
  (use-package ligature
    :defer t
    :vc (:fetcher github :repo "mickeynp/ligature.el")
    :if (string-match "HARFBUZZ" system-configuration-features)
    :hook ((prog-mode text-mode) . ligature-mode)
    :config
    ;; Enable "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www")))  
#+end_src

I created a small package to manage my fixed width font(with ligature), proportional font, CJK font and emoji font.
#+begin_src emacs-lisp :noweb yes
  (use-package appr
    :load-path "lisp"
    :hook (after-init . appr)
    :init
    <<THEME>>
    :custom
    (appr-default-font-size (perdev-get-value 'my/default-font-size 13))
    (appr-cjk-font-list     '("WenQuanYi Micro Hei"
                              "WenQuanYi Zen Hei"
                              "Microsoft YaHei"
                              "Microsoft JhengHei"))
    (appr-emoji-font-list '("Noto Color Emoji"
                            "Noto Emoji"
                            "Segoe UI Emoji"
                            "Symbola"
                            "Apple Color Emoji"))

    (appr-variable-pitch-font-list '("Fira Sans"
                                     "Iosevka Aile"))
    )  
#+end_src

* Programming Setup
** Project management 
*** Magit for managing git repos
#+begin_src emacs-lisp
;;sync
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))

(use-package ssh-agency
  :vc (:fetcher github :repo "magit/ssh-agency")
  :hook (magit-credential . ssh-agency-ensure))
#+end_src
*** Projectile
There is not thing special here, we just add a key-map and use ~alien~ indexing method (git) across all platform.
#+begin_src emacs-lisp

(use-package projectile
  :ensure t
  :diminish projectile-mode
  :init
  (projectile-mode +1)
  :bind (:map projectile-mode-map
	 ("C-c p" . projectile-command-map)
         :map projectile-command-map
	 ;; the other commands are configure/packge/install/test/run
	 ("c" . projectile-compile-project))
  :custom
  (projectile-enable-caching t)
  (projectile-indexing-method 'alien))

(use-package projectile-ripgrep :ensure t :pin melpa :after projectile)
#+end_src
*** Color-rg for refactoring and code search.

#+begin_src emacs-lisp
  (use-package color-rg
    :vc (:fetcher github :repo "manateelazycat/color-rg")
    :config (when (eq system-type 'windows-nt)
              (setq color-rg-command-prefix "powershell"))
    :custom (color-rg-search-no-ignore-file nil))
#+end_src

** EDiff setup
#+begin_src emacs-lisp
(use-package ediff :ensure nil ;;built-in package
  :custom
  ;;do not use the multi-frame in graphics mode
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  (ediff-split-window-function #'split-window-vertically))
#+end_src

** Editing packages
*** [[https://github.com/xeechou/fmo-mode.el][fmo-mode]] for code re-formatting
prerequisite : format-all
#+begin_src emacs-lisp
  (use-package format-all :ensure t :pin melpa :defer t)
  (use-package difflib :ensure t :pin melpa :defer t)
#+end_src

#+begin_src emacs-lisp
(use-package fmo-mode :ensure t :pin melpa
  :custom (fmo-ensure-formatters t)
  :hook (((c-mode c++-mode c-ts-mode c++-ts-mode) . fmo-mode)
         ((hlsl-mode glsl-mode azsl-mode ) . fmo-mode)))
#+end_src

*** Clean up the white spaces
#+begin_src emacs-lisp
(use-package whitespace-cleanup-mode
  :ensure t
  :diminish whitespace-cleanup-mode
  :hook ((prog-mode . whitespace-cleanup-mode)))
#+end_src

*** parenthesis management
#+begin_src emacs-lisp
  (use-package elec-pair
    :diminish electric-pair-mode
    :hook ((prog-mode text-mod outline-mode) . electric-pair-mode))
#+end_src

#+begin_src emacs-lisp
(use-package paren
  :ensure t
  :diminish show-paren-mode
  :hook (prog-mode . show-paren-mode)
  :config (setq show-paren-style 'parenthesis))
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t :defer t
  :hook ((emacs-lisp-mode lisp-interaction-mode) . rainbow-delimiters-mode))  
#+end_src

#+begin_src emacs-lisp
(use-package paredit
  :ensure t :defer t :pin melpa
  :hook ( (emacs-lisp-mode lisp-interaction-mode) . paredit-mode))  
#+end_src

*** fic-mode: keyword highlighting
#+begin_src emacs-lisp
(use-package fic-mode ;;show FIXME/TODO in comments
  :vc (:fetcher github :repo "lewang/fic-mode")
  :diminish fic-mode
  :hook (prog-mode . fic-mode)
  :custom (fic-highlighted-words '("FIXME" "TODO" "BUG" "NOTE")))
#+end_src
*** Snippets
#+begin_src emacs-lisp
;; yasnippet
(use-package yasnippet-snippets
  :ensure t
  :config
  (yas-reload-all)
  :hook ((prog-mode outline-mode cmake-mode) . yas-minor-mode))
#+end_src

*** Column width setup
#+begin_src emacs-lisp
  ;; visual fill column
  (use-package visual-fill-column
    :ensure t
    :init
    (setq-default fill-column 79)
    (setq-default visual-fill-column-width 120)
    :hook
    (prog-mode . turn-on-auto-fill)
    (visual-line-mode . visual-fill-column-mode)
    ((text-mode outline-mode) . visual-line-mode))
#+end_src

#+begin_src emacs-lisp

;; diminish some builtin packages
(diminish 'eldoc-mode)
(diminish 'abbrev-mode)
#+end_src
*** Hide show
Hide show works by regex searching. You can customize it with [[http://doc.endlessparentheses.com/Var/hs-special-modes-alist.html][hs-special-modes-alist]]. You define the ~START~, ~END~, ~COMMENT~ and a ~FORWARD-SEXP-FUNC~. Which is a ~forward-sexp~ goes to end of the marching.

#+begin_src emacs-lisp :noweb yes
  (use-package hideshow
    :hook ((prog-mode . hs-minor-mode)
           (nxml-mode . hs-minor-mode))
    :diminish hs-minor-mode
    :bind (;; the two map didn't work, polluting global map
           ("C-c C-h t" . hs-toggle-hiding)
           ("C-c C-h l" . hs-hide-level)
           ("C-c C-h a" . hs-hide-leafs)
           ("C-c C-h s" . hs-show-block)
           )
    :config
    (setq hs-isearch-open t)
    <<HS_MODES>>
    :preface
    <<HS_HIDE_LEAVES>>
    )
#+end_src

**** Hide Show for XML
XML is very easy to setup, The ~BEGIN~ and ~END~ are simply the tag brackets, xml also has its own forward 

#+begin_src emacs-lisp :tangle no :noweb-ref HS_MODES
  (add-to-list 'hs-special-modes-alist
               '(nxml-mode
                 "<!--\\|<[^/>]*[^/]>"
                 "-->\\|</[^/>]*[^/]>"
                 "<!--"
                 sgml-skip-tag-forward
                 nil))
#+end_src

**** Hide show for CMake Mode
#+begin_src emacs-lisp :tangle no :noweb-ref HS_MODES
  (defun hs-cmake-forward-sexp-once ()
    "forward cmake s-expression once"
    (when (looking-at hs-block-start-regexp)
      (let ((matched-key-beg (match-string-no-properties 1))
            (matched-key-end "")
            end-point)
        ;; now we search for the end regular expression
        (save-excursion
          ;; loop until we find the END that matches the START 
          (while (not (string= matched-key-beg matched-key-end))
            ;; search forward
            (re-search-forward hs-block-end-regexp)
            ;; and updating the point and end match data.
            (setq matched-key-end (match-string-no-properties 1))
            (setq end-point (match-beginning 0)))
          )
        (goto-char end-point))))

  (defun hs-cmake-forward-sexp (args)
    "forward cmake s-expression ARGS times"
    (dotimes (i args)
      (hs-cmake-forward-sexp-once)))

  (add-to-list 'hs-special-modes-alist
               '(cmake-mode
                 ;;match the begining
                 "^\\([:blank:]*\\)\\(?1:if\\|function\\|macro\\) *(.*)"
                                          ;match the end
                 "^\\([:blank:]*\\)end\\(?1:[A-Za-z]+\\) *(.*)"
                 ;;comment
                 "#"
                 hs-cmake-forward-sexp
                 nil))
#+end_src

**** Hide leaves
Recursively run hide show on all leaves
#+begin_src emacs-lisp :tangle no :noweb-ref HS_HIDE_LEAVES
  (defun hs-hide-leafs-recursive (minp maxp)
    "Hide blocks below point that do not contain further blocks in
    region (MINP MAXP)."
    (when (hs-find-block-beginning)
      (setq minp (1+ (point)))
      (funcall hs-forward-sexp-func 1)
      (setq maxp (1- (point))))
    (unless hs-allow-nesting
      (hs-discard-overlays minp maxp))
    (goto-char minp)
    (let ((leaf t))
      (while (progn
               (forward-comment (buffer-size))
               (and (< (point) maxp)
                    (re-search-forward hs-block-start-regexp maxp t)))
        (setq pos (match-beginning hs-block-start-mdata-select))
        (if (hs-hide-leafs-recursive minp maxp)
            (save-excursion
              (goto-char pos)
              (hs-hide-block-at-point t)))
        (setq leaf nil))
      (goto-char maxp)
      leaf))
  
  (defun hs-hide-leafs ()
    "Hide all blocks in the buffer that do not contain subordinate
    blocks.  The hook `hs-hide-hook' is run; see `run-hooks'."
    (interactive)
    (hs-life-goes-on
     (save-excursion
       (message "Hiding blocks ...")
       (save-excursion
         (goto-char (point-min))
         (hs-hide-leafs-recursive (point-min) (point-max)))
       (message "Hiding blocks ... done"))
     (run-hooks 'hs-hide-hook)))
#+end_src

**** Hide ~#ifdef~
Hide show does not work with ~#ifdef~, the hideif package
#+begin_src emacs-lisp
  (use-package hideif
    :ensure t
    :diminish hide-ifdef-mode
    :hook ((c++-mode c++-ts-mode c-mode c-ts-mode)  . hide-ifdef-mode)
    :config
    (setq hide-ifdef-read-only t)
    )
#+end_src

** Tree-sitter
[[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] is a new major mode managements package.

*** Define indentation rules
here is my custom rule just to disable namespace indentation ~(setq
treesit--indent-verbose t)~ to see if your rule works ~(treesit-check-indent
c++-mode)~ to check your rules against ~c++-mode~.

#+begin_src emacs-lisp
  (when (treesit-available-p)
    (require 'treesit)

    (defun my/indent-rules ()
      `(
        ((n-p-gp "declaration" "declaration_list" "namespace_definition")
         parent-bol 0)
        ((n-p-gp "comment" "declaration_list" "namespace_definition") parent-bol 0)
        ((n-p-gp "class_specifier" "declaration_list" "namespace_definition") parent-bol 0)
        ((n-p-gp "function_definition" "declaration_list" "namespace_definition")
         parent-bol 0)
        ((n-p-gp "template_declaration" "declaration_list" "namespace_definition")
         parent-bol 0)
        ,@(alist-get 'bsd (c-ts-mode--indent-styles 'cpp)))
      ))
  #+end_src

The difficult thing is to setup the indentations. See [[https://lists.gnu.org/archive/html/help-gnu-emacs/2023-08/msg00445.html][gnu archive]] and this
[[https://casouri.github.io/note/2023/tree-sitter-starter-guide/index.html#Indentation][blog-post]] is very useful.

*** Treesit auto
treesit-auto does not work on windows at moment.
#+begin_src emacs-lisp
(use-package treesit-auto
    :unless (or (eq system-type 'windows-nt)
                (not (treesit-available-p)))
    :ensure t
    :custom
    (c-ts-mode-indent-style #'my/indent-rules)
    :hook ((after-init . treesit-auto-mode))
    :config
    (setq-default treesit-font-lock-level 3)
    ;;Error here if (treesit-auto-add-to-auto-mode-alist 'all) because the
    ;;extensions for glsl is nil. See
    ;;https://github.com/renzmann/treesit-auto/blob/main/treesit-auto.el#L161. We
    ;;end up adding a (nil . glsl-ts-mode) to auto-mode-alist. Which causes the
    ;;auto-mode to fail to load anything.

    ;; to fix this, we need to build a treesit-ready-langs which contains only ones has extensions
    (setq treesit-ready-langs
          (seq-map #'treesit-auto-recipe-lang
                   (seq-filter
                    (lambda (r) (if (and (treesit-auto-recipe-ext r) ;;has extensions
                                         (fboundp (treesit-auto-recipe-ts-mode r))) ;;has mode
                                    r nil))
                    treesit-auto-recipe-list)))
    (treesit-auto-add-to-auto-mode-alist treesit-ready-langs)
    (setq treesit-auto-install 'prompt))
#+end_src

** Company mode

#+begin_src emacs-lisp
  (use-package company-c-headers :ensure t :defer t)
  ;; (setq clang-known-modes '(c++-mode c-mode))
#+end_src

#+begin_src emacs-lisp :noweb yes
  (use-package company
    :ensure t
    :defer t
    ;;one-liner setups for languages
    :hook (
           <<COMPANY_HOOKS>>
           )
    :config

    (setq company-minimum-prefix-length 2
          company-idle-delay 0.1
          company-async-timeout 10
          company-backends  '(company-files
                              company-keywords
                              company-yasnippet
                              company-capf)))
#+end_src

*** Built-in company hooks
CMake we just add company-dabbrev and company-cmake.
#+begin_src emacs-lisp :tangle no :noweb-ref COMPANY_HOOKS
  (cmake-mode . company-mode)
  (cmake-mode .  (lambda () (my/merge-list-buffer-local
                             'company-backends
                             (list 'company-cmake 'company-dabbrev))))
#+end_src

- company-elisp ::  is remove so we just rely on internal backends.
#+begin_src emacs-lisp :tangle no :noweb-ref COMPANY_HOOKS
  (emacs-lisp-mode . company-mode)
#+end_src

- Python :: add ~python-ts-mode~, we use  ~company-capf~ by language servers.

#+begin_src emacs-lisp :tangle no :noweb-ref COMPANY_HOOKS
  ((python-mode python-ts-mode) . company-mode)
#+end_src

*NOTE* that for python I use [[https://github.com/pypa/pipx][pipx]] to install ~python-lsp-server~. For the other packages installed with ~pipx~. You need to inject them into ~python-lsp-server~ to have ~company-capf~ working.

#+begin_src shell-script :tangle no
  pipx inject python-lsp-server [[your packages here]]
#+end_src


- TEXT :: We add company-emoji to company backends.
#+begin_src emacs-lisp
  (use-package company-emoji
    :defer t
    :ensure t
    :after company)
#+end_src

Outline mode includes org mode and markdowns
#+begin_src emacs-lisp :tangle no :noweb-ref COMPANY_HOOKS
  (outline-mode . company-mode) ;;enable for org mode
  (outline-mode . (lambda () (my/merge-list-buffer-local
                              'company-backends
                              (list'company-dabbrev 'company-emoji))))
#+end_src

simple text mode:
#+begin_src emacs-lisp :tangle no :noweb-ref COMPANY_HOOKS
  (text-mode . company-mode)
  (text-mode . (lambda () (my/merge-list-buffer-local
                           'company-backends
                           (list 'company-dabbrev 'company-emoji))))
#+end_src

** Eglot mode

#+begin_src emacs-lisp

  ;; eglot configuration, switching to eglot after emacs 29
  (use-package eglot
    :ensure t :defer t
    :hook (((c++-mode c++-ts-mode) . eglot-ensure)
           ((c-mode c-ts-mode) . eglot-ensure)
           ((python-mode python-ts-mode) . eglot-ensure))
    :custom
    (eglot-extend-to-xref t)
    ;;inlay-hints are annoying
    (eglot-ignored-server-capabilities '(:inlayHintProvider))
    :config
    ;;by default eglot forces company to only use company-capf, I lose a lot of
    ;;backends in this way
    (setq eglot-stay-out-of '(company))
    ;;eldoc's multi-line mini buffer is really annoying, turn it off
    (setq eldoc-echo-area-use-multiline-p nil)
    ;; clangd often mess around with headers, turn this off.
    (add-to-list 'eglot-server-programs
                 '((c++-mode c-mode c-ts-mode c++-ts-mode)
                   . ("clangd"
                      "-j=4"
                      "--header-insertion=never"
                      "--header-insertion-decorators=0")))
    ;;C++ requires clangd, python requires python-language server
    :bind (:map eglot-mode-map
                ;; we just use the default binding here, so comment it out
                ;; ("M-." . xref-find-definitions)
                ;; ("M-?" . xref-find-references)
                ;; ("M-," . xref-go-back)
                ("C-c R"  . eglot-rename)
                ("C-c H"  . eldoc))
    )
#+end_src

** Debugging with [[https://microsoft.github.io/debug-adapter-protocol//specification.html][debug adapter protocol]]
*** [[https://github.com/svaante/dape][dape]] configs

#+begin_src emacs-lisp
(use-package dape :ensure t ;; available in elpa
  :preface
  ;; By default dape shares the same keybinding prefix as `gud'
  ;; If you do not want to use any prefix, set it to nil.
  (setq dape-key-prefix "\C-x\C-a")

  :hook
  ;; Save breakpoints on quit
  (kill-emacs . dape-breakpoint-save)
  ;; Load breakpoints on startup
  (after-init . dape-breakpoint-load)

  :config
  ;; Turn on global bindings for setting breakpoints with mouse
  (dape-breakpoint-global-mode)

  ;; Info buffers to the right
  (setq dape-buffer-window-arrangement 'right)

  ;; Pulse source line (performance hit)
  ;; (add-hook 'dape-display-source-hook 'pulse-momentary-highlight-one-line)

  ;; Showing inlay hints
  (setq dape-inlay-hints t)

  ;; Save buffers on startup, useful for interpreted languages
  ;; (add-hook 'dape-start-hook (lambda () (save-some-buffers t t)))

  ;; Kill compile buffer on build success
  (add-hook 'dape-compile-hook 'kill-buffer)

  ;; Projectile users
  ;; (setq dape-cwd-function 'projectile-project-root)
  )

;; Enable repeat mode for more ergonomic `dape' use
(use-package repeat
  :config
  (repeat-mode))
#+end_src

*** [[https://github.com/vadimcn/codelldb/blob/master/MANUAL.md][codelldb]] setup
So far I had the most success with ~codelldb~, however there are couple of issues:

**** I get some problems hitting breakpoints at program start up
a quick hack is to use ~:stopOnEntry~. You can setup ~dap-command~ on ~.dir-locals.el~

#+begin_src emacs-lisp :tangle no
(setq (dape-command (codelldb-cc :stopOnEntry t :args ["arg0" "args1"])))  
#+end_src
**** you may run into permission issues on Mac

*** [[https://github.com/helix-editor/helix/wiki/Debugger-Configurations#install-debuggers][lldb-dap]] installation
- On MacOS, you can find the ~lldb-dap~ through ~xcrun -f lldb-dap~, it is usually under:
#+begin_src :tangle no
/Applications/Xcode.app/Contents/Developer/usr/bin/lldb-dap  
#+end_src
then you can link against it ~ln -s /Application//.../lldb-dap /usr/local/bin/lldb-dap~

** [[https://github.com/rurban/rmsbolt][Rmsbolt]] mode
RMSBolt mode mimics [[https://godbolt.org/][Compiler Explorer]] in Emacs. Making changes with ~C-c C-c~, which is bonded to ~:bind (:map rmsbolt-mode-map ("C-c C-c" . rmsbolt-compile))~

#+begin_src emacs-lisp :noweb yes
   ;;compiler explorer in emacs
  (use-package rmsbolt   :ensure t :defer t
    :init
    (defun my/cc-ts-rmsbolt-hook ()
      ;;setup languages
      (cond
       <<RMSBOLT_LANGS>>
       ))
    :hook
    (rmsbolt-mode . my/cc-ts-rmsbolt-hook))
#+end_src

Language setups:  C and C++, we use ~clang++~ and ~llvm-cxfilt~. In this way it supports both Linux and windows.
#+begin_src emacs-lisp :tangle no :noweb-ref RMSBOLT_LANGS
  ;; cond
  ((or (eq major-mode 'c-ts-mode)
       (eq major-mode 'c-mode))
   (setq rmsbolt-language-descriptor
         (make-rmsbolt-lang :compile-cmd "clang"
                            :supports-asm t
                            :supports-disass t
                            :demangler "llvm-cxxfilt"
                            :compile-cmd-function #'rmsbolt--c-compile-cmd
                            :disass-hidden-funcs
                            rmsbolt--hidden-func-c)))

  ((or (eq major-mode 'c++-ts-mode)
       (eq major-mode 'c++-mode))
   (setq rmsbolt-language-descriptor
         (make-rmsbolt-lang :compile-cmd "clang++"
                            :supports-asm t
                            :supports-disass t
                            :demangler "llvm-cxxfilt"
                            :compile-cmd-function #'rmsbolt--c-compile-cmd
                            :disass-hidden-funcs rmsbolt--hidden-func-c)))  
#+end_src

**** TODO However for unknown reason. The [[https://github.com/emacsmirror/rmsbolt/blob/master/rmsbolt.el#L230][rmsbolt-line-mapping]] not working well on windows. We should probably disable this.
**** TODO add shader languages like HLSL
#+begin_src shell
dxc -Zi -Qembed_debug -Fc /tmp/output.s -Tps_6_6 example.hlsl #this lacks of demangler
#+end_src

** Languages
*** C family
#+begin_src emacs-lisp
  ;; C family
  (use-package cc-mode
    :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
           ("\\.m\\'" . c-mode)
           ("\\.mm\\'" . c++-mode)
           ("\\.inl\\'" . c++-mode))
    :preface
    (defun my/cmode-hook ()
      ;;default settings
      (setq c-default-style "linux"
            c-basic-offset 8)
      (c-set-offset 'inextern-lang 0)
      (c-set-offset 'innamespace 0)
      (c-set-offset 'inline-open 0))

    (defun my/cmode-company-hook ()
      ;;override default company backends because eglot not compatible with
      ;;company-clang
      (set (make-local-variable 'company-backends)
           '(company-capf
             company-files
             company-keywords
             company-dabbrev
             company-yasnippet)))
    :config
    (require 'cc-file-styles)
    (c-add-style (car cc-file-style-o3de)
                 (cdr cc-file-style-o3de))
    (c-add-style (car cc-file-style-sparroh)
                 (cdr cc-file-style-sparroh))
    :hook
    ((c-mode-common . my/cmode-hook)
     ((c++-mode c++-ts-mode c-mode c-ts-mode) . company-mode)
     ((c++-mode c++-ts-mode c-mode c-ts-mode) . my/cmode-company-hook)))
#+end_src
*** Build Scripts
#+begin_src emacs-lisp
  ;;cmake
  (use-package cmake-mode
    :ensure t :defer t
    :mode (("/CMakeLists\\.txt\\'" . cmake-mode)
           ("\\.cmake\\'" . cmake-mode)))
#+end_src

#+begin_src emacs-lisp
  ;;mesonbuild
  (use-package meson-mode
    :ensure t
    :defer t
    :mode (("/meson\\.build\\'" . meson-mode))
    :hook ((meson-mode . company-mode))
    )
#+end_src

*** Shader languages
**** GLSL
#+begin_src emacs-lisp :noweb yes
  ;; glsl
  (use-package glsl-mode
    :ensure t
    :defer t
    :init
    (defun my/glsl-mode-hook ()
      <<GLSL_LSP>>
        )
    :mode (("\\.glsl\\'" . glsl-mode)
           ("\\.vert\\'" . glsl-mode)
           ("\\.frag\\'" . glsl-mode)
           ("\\.geom\\'" . glsl-mode)
           ("\\.comp\\'" . glsl-mode)
           ("\\.rgen\\'" . glsl-mode)
           ("\\.rchit\\'" . glsl-mode)
           ("\\.rmiss\\'" . glsl-mode))
    :hook
    ((glsl-mode . company-mode)
     (glsl-mode . my/glsl-mode-hook)))
#+end_src

GLSL has a language server ~company-glsl~
#+begin_src emacs-lisp
  (use-package company-glsl
    :defer t
    :ensure t
    :after company)
#+end_src

It depends on ~glslangValidator~ to be available.
#+begin_src emacs-lisp :tangle no :noweb-ref GLSL_LSP
  (when (executable-find "glslangValidator")
    (make-variable-buffer-local 'company-backends)
    (add-to-list 'company-backends 'company-glsl))
#+end_src

**** HLSL
#+begin_src emacs-lisp :noweb yes
  ;; hlsl
  (use-package hlsl-mode
    :vc (:fetcher github :repo "xeechou/hlsl-mode.el")
    :defer t
    :mode (("\\.fxh\\'"    . hlsl-mode)
           ("\\.hlsl\\'"   . hlsl-mode)
           ("\\.vs\\'"     . hlsl-mode)
           ("\\.ps\\'"     . hlsl-mode)
           ("\\.hs\\'"     . hlsl-mode) ;;hull shader
           ("\\.ds\\'"     . hlsl-mode) ;;domain shader
           ("\\.cs\\'"     . hlsl-mode) ;;compute shader
           ("\\.ms\\'"     . hlsl-mode) ;;mesh shader
           ("\\.as\\'"     . hlsl-mode) ;;amplification shader
           ("\\.lib\\'"    . hlsl-mode) ;;ray-tracing shader library
           )
    :init
    (defun my/hlsl-mode-hook ()
      <<HLSL_LSP>>
      )
    :hook ((hlsl-mode . company-mode)
           ;;TODO there is some bug on windows that :config block always run. I
           ;;have to put it in hook
           (hlsl-mode . my/hlsl-mode-hook)))
#+end_src

setup the slangd as language server if it's available
#+begin_src emacs-lisp :tangle no :noweb-ref HLSL_LSP
  (if (and (executable-find "slangd")
           (eq major-mode 'hlsl-mode)) ;; only enables for hlsl-mode
      ;;available
      (progn
        (eglot-ensure)
        (add-to-list 'eglot-server-programs
                     `(hlsl-mode . ("slangd")))
        (add-to-list 'company-backends 'company-capf))
    ;; not available
    (my/merge-list-buffer-local 'company-backends
                           (list 'company-keywords 'company-dabbrev)))
#+end_src

**** AZSL
Currently AZSL does not have a language server so no [[https://company-mode.github.io/manual/Backends.html#index-company_002dcapf][company-capf]] available. I only use [[https://company-mode.github.io/manual/Backends.html#index-company_002ddabbrev][company-dabbrev]] and [[https://company-mode.github.io/manual/Backends.html#index-company_002dkeywords][company-keywords]].

#+begin_src emacs-lisp
  (use-package azsl-mode
    :vc (:fetcher github :repo "xeechou/azsl-mode.el")
    :defer t
    :mode (("\\.azsl\\'"  . azsl-mode)
           ("\\.azsli\\'" . azsl-mode))
    :hook ((azsl-mode . company-mode)))
#+end_src

**** unity shaders

#+begin_src emacs-lisp
  (use-package shader-mode
    :disabled
    :mode (("\\.shader\\'" . hlsl-mode)))  
#+end_src

*** Rust
#+begin_src emacs-lisp
  (use-package rust-mode :ensure t :defer t
    :mode (("\\.rs\\'" . rust-mode))
    :hook ((rust-mode rust-ts-mode) . company-mode)
    :init
    (when (executable-find "rust-analyzer")
      (add-hook 'rust-mode-hook 'eglot-ensure)
      (add-hook 'rust-ts-mode-hook 'eglot-ensure)))
#+end_src

*** Go Lang
#+begin_src emacs-lisp
  ;; golang
  (use-package go-mode :ensure t :defer t
    :mode (("\\.go\\'" . go-mode)
           ("\\.mode\\'" . go-mode))
    :hook ((go-mode . (lambda () (add-hook 'before-save-hook 'gofmt-before-save nil t)))))
#+end_src
*** Web programmings
#+begin_src emacs-lisp
  ;;javascript
  (use-package rjsx-mode
    :ensure t
    :defer t
    :mode (("\\.js\\'" . rjsx-mode))
    :config (setq js-indent-level 2)
    )

  (use-package web-mode
    :ensure t
    :defer t    
    :pin melpa
    :mode ("\\.html?\\'" . web-mode))

  ;;typescript
  (use-package typescript-mode
    :ensure t
    :defer t
    :mode (("\\.ts\\'" . typescript-mode))
    :config
    (setq typescript-indent-level 2)
    (setq-default indent-tabs-mode nil)
    )

  (use-package json-mode
    :ensure t
    :defer t
    :pin melpa
    :mode (("\\.json\\'" . json-mode)
           ;; O3DE passes and assets use json format
           ("\\.pass\\'"         . json-mode)
           ("\\.azasset\\'"      . json-mode)
           ("\\.setreg\\'"       . json-mode)
           ("\\..setregpatch\\'" . json-mode)
           ("wireplumber\\.conf\\'" . json-mode)))
#+end_src
*** Flutter
#+begin_src emacs-lisp
  ;;dart
  (use-package dart-mode
    :ensure t
    :defer t
    :mode (("\\.dart\\'" . dart-mode))
    :config
    (with-eval-after-load 'projectile
      (projectile-register-project-type 'flutter '("pubspec.yaml")
                                        :project-file "pubspec.yaml"
                                        :compile "flutter build"
                                        :test "flutter test"
                                        :run "flutter run"
                                        :src-dir "lib/"))
    )
#+end_src
*** Beancount
The [[https://github.com/beancount/beancount][beancount]] is a text based double entry ledger system.
#+begin_src emacs-lisp
  (use-package beancount
    :when (executable-find "bean-check")
    :vc (:fetcher github :repo "beancount/beancount-mode")
    :defer t
    :mode (("\\.beancount\\'" . beancount-mode))
    :config
    (setq-local electric-indent-chars nil)
    :hook
    ((beancount-mode . outline-minor-mode)
     (beancount-mode . flymake-bean-check-enable))
    :bind (:map beancount-mode-map
                ("C-c C-n" . outline-next-visible-heading)
                ("C-c C-p" . outline-previous-visible-heading))
    )
#+end_src
Notes:
1. The automatic indentation behavior ~electric-indent-chars~ may be undesired for beancount. Disable it
2. enable the ~outline-minor-mode~ for managing large text

I use [[https://github.com/pypa/pipx][pipx]] to install beancount locally, you can follow the same process
#+begin_src shell :tangle no
  # this creates a python venv for beancount
  pipx install beancount
  #inject fava to beancount venv and adding "fava" executable
  pipx inject --include-apps beancount fava
#+end_src

*** Other languages
#+begin_src emacs-lisp
  ;;lua
  (use-package lua-mode :ensure t :defer t
    :mode (("\\.lua\\'" . lua-mode))
    :hook
    ((lua-mode . company-mode)
     (lua-mode . (lambda ()
                   (when (executable-find "lua-language-server")
                     (eglot-ensure))))))

  ;;graphviz dot
  (use-package graphviz-dot-mode :ensure t :defer t
    :mode (("\\.dot\\'" . graphviz-dot-mode)))



  (use-package gdscript-mode :ensure t :defer t
    :mode (("\\.gd\\'" . gdscript-mode)))

  (use-package markdown-mode :ensure t :defer t
    :mode (("\\.md\\'" . markdown-mode)))

  (use-package octave :ensure t :defer t
    :mode (("\\.m\\'" . octave-mode)))

  (use-package yaml-mode :ensure t :defer t
    :mode (("\\.yml\\'" . yaml-mode)))

  (use-package powershell :ensure t :defer t
    :mode (("\\.ps1\\'" . powershell-mode)))

  ;; jenkins
  ;; Jenkins/Groovy support
  (use-package groovy-mode :ensure t :defer t)
  (use-package jenkinsfile-mode
    :after groovy-mode
    :vc (:fetcher github :repo "john2x/jenkinsfile-mode")
    :mode (("Jenkinsfile\\'" . jenkinsfile-mode)))

  ;;universal scene descriptor
  (use-package usda-mode
    :defer t
    :load-path "lisp/"
    :mode (("\\.usda\\'" . usda-mode)
           ("\\.usd\\'"  . usda-mode)))

  ;; built-in
  (use-package nxml-mode
    :defer t
    :mode (("\\.xml\\'" . nxml-mode)
           ("\\.ofx\\'" . nxml-mode)
           ;;quick book
           ("\\.qfx\\'" . nxml-mode)))
#+end_src

* LLMs
** Register the APIs
personally I use a device local ~llm-api.el~ to register all my keys.
#+begin_src emacs-lisp
(let ((llm-api-file (expand-file-name "llm-api.el" (my/dotfile-dir))))
  (when (file-exists-p llm-api-file)
    (load llm-api-file)))
#+end_src

** Command keymap for LLMs

#+begin_src emacs-lisp
(define-prefix-command 'my/llm-keymap)
(global-set-key (kbd "C-c i") 'my/llm-keymap)'
#+end_src


** [[https://aider.chat/][Aider]]
Aider is a *command line* based *project-wise* AI chat bot, the [[https://aider.chat/#features][features]] is like adding multiple files to aider like ~aider <file1> <file2> ...~ then you can ask it to add new features, tests. Fix bugs, refactoring code, update docs.

#+begin_src emacs-lisp :noweb yes
(use-package vterm  :if (executable-find "vterm-ctrl") :ensure t  :pin melpa)

(use-package aidermacs
  :when (file-exists-p (expand-file-name "llm-api.el" (my/dotfile-dir)))
  :pin melpa :ensure t :defer t
  :bind (:map my/llm-keymap ("a" . aidermacs-transient-menu))
  :init
  (if (executable-find "vterm-ctrl")
    (setq aidermacs-backend 'vterm))
  :config
  <<AIDER_BACKENDS>>

  :custom
  ;; Disable auto-commits
  (aidermacs-auto-commits nil)
  )

#+end_src

*** Backends setup
The code gets evaluated sequentially, the later models gets the higher priorities.

**** openAI
#+begin_src emacs-lisp :tangle no :noweb-ref AIDER_BACKENDS
(when (boundp 'my/llm-openai-key)
  (setenv "OPENAI_API_KEY" my/llm-openai-key)
  (setq aidermacs-default-chat-mode 'architect)
  (setq aidermacs-default-model "gpt-4o")
)
#+end_src

**** Claude
#+begin_src emacs-lisp :tangle no :noweb-ref AIDER_BACKENDS
(when (boundp 'my/llm-openrouter-key)
  (setenv "ANTHROPIC_API_KEY" my/llm-anthropic-key)
  ;;setup corresponding models
  (setq aidermacs-default-chat-mode 'architect)
  (setq aidermacs-default-model "sonnet")
  (setq aidermacs-editor-model "opus"))
#+end_src

**** Ollama
  Enables Ollama when the port is enabled.
#+begin_src emacs-lisp :tangle no :noweb-ref AIDER_BACKENDS
(when (and (my/test-port-open "127.0.0.1" 11434)
	   (boundp 'my/llm-ollama-model))
  (setenv "OLLAMA_API_BASE" "http://127.0.0.1:11434")
  (setq aidermacs-default-caht-mode 'ask)
  (setq aidermacs-default-model (concat "ollama_chat/" my/llm-ollama-model))
  )
#+end_src

** [[https://github.com/karthink/gptel][GPTel]]
Firstly we need methods to securely store our api keys
#+begin_src emacs-lisp :noweb yes
(use-package gptel
  :when (file-exists-p (expand-file-name "llm-api.el" (my/dotfile-dir)))
  :pin melpa :ensure t :defer t
  :custom
  (gptel-default-mode 'org-mode)
  :bind
  (:map my/llm-keymap ("g" . gptel-menu))
  :config
  ;;setup directives
  (setq gptel-directives
        (delete-dups
         (append gptel-directives
                 '(
                   <<GPTEL_DIRECTIVES>>
                   ))))
  ;;setup backends
  <<GPTEL_BACKENDS>>
  ;;setup proxies
  <<GPTEL_PROXY>>
  )
#+end_src

*** Directives
**** Command line helper
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_DIRECTIVES
  (cliwiz . "You are a command line helper. Generate command line that do what requested. Without any additional description or explaination. Generate ONLY the command, I will edit before running")
#+end_src

**** Explain the code
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_DIRECTIVES
  (explain . "Explain what this code does to a novice programmer")
#+end_src
**** commit message
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_DIRECTIVES
(commit . "You are an expert at writing Git commit messages.
Generate **only** the commit message, nothing else.

DECISION PROCESS:
1. Count changed files
2. If 1 file: check if change is simple or complex
3. Apply the appropriate format

FORMAT RULES:

A. Single File + Simple Change (one clear purpose):
   * path/to/file: Description. (≤72 chars)

   NO subject line, NO blank lines, JUST this one line.

B. Single File + Complex Change (multiple purposes/major refactor):
   Subject line (≤50 chars, imperative mood, NO period)

   Optional body paragraph explaining why (wrap at 72 chars).

   * path/to/file (func1, func2): Description.

C. Multiple Files (2+ files changed):
   Subject line (≤50 chars, imperative mood, NO period)

   Optional body paragraph explaining why (wrap at 72 chars).

   * path/to/file1 (func1): Description.
   * path/to/file2 (func2): Another description.

D. Trivial Changes:
   Add `; ` prefix for typos/comments/docs.
   Example: `; * file: Fix typo.`

SIMPLE vs COMPLEX (single file):
- Simple: one function, one clear fix/addition
- Complex: multiple functions, refactoring, or architectural change")
#+end_src


*** OpenAI key
#+begin_src  emacs-lisp :tangle no :noweb-ref GPTEL_BACKENDS
(when (boundp 'my/llm-openai-key)
  (setq gptel-api-key my/llm-openai-key))
#+end_src

*** Gemini backend
I prefer the google genimi, set it to default if available
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_BACKENDS
(when (boundp 'my/llm-gemini-key)
  (setq gptel-model 'gemini-2.5-pro-exp-03-25
        gpt-backend  (gptel-make-gemini "Gemini"
                       :key my/llm-gemini-key
                       :stream t)))
#+end_src
*** Claude backend
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_BACKENDS
(when (boundp 'my/llm-anthropic-key)
  (setq gptel-model 'claude-3-7-sonnet-20250219
        gptel-backend
        (gptel-make-anthropic "Claude"
          :stream t
          :key my/llm-anthropic-key)))
#+end_src

*** Ollama backend, run locally
Ollama backend runs locally on your pc
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_BACKENDS
  (when (and (my/test-port-open "127.0.0.1" 11434)
             (boundp 'my/llm-ollama-model))
    (gptel-make-ollama "Ollama"
      :host "localhost:11434"
      :stream t
      :models `(,my/llm-ollama-model)))
#+end_src

*** Setup proxies
Unfortunately my proxy requires some additional arguments for curl ~-k~ or ~--ssl-no-revoke~.

#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_PROXY
  ;;initialize the proxy
  (when (and gptel-use-curl (my/has-or-get-proxy))
      (setq gptel-proxy (my/has-or-get-proxy)))

  (defun my/gptel-toggle-proxy  ()
    "Toggle the gptel proxy based on the environment."
    (interactive)
    (when (and gptel-use-curl (my/has-or-get-proxy))
      (if (string= gptel-proxy "")
          (setq gptel-proxy (my/has-or-get-proxy))
        (setq gptel-proxy ""))))
#+end_src

We add additional backend for when using proxy
#+begin_src emacs-lisp :tangle no :noweb-ref GPTEL_PROXY
  ;; openai
  (when (and (my/has-or-get-proxy) (boundp 'my/llm-openai-key))
      (gptel-make-openai "ChatGPT-no-ssl-check"
        :key 'my/llm-openai-key
        :stream t
        :models '("gpt-3.5-turbo" "gpt-3.5-turbo-16k" "gpt-4"
                  "gpt-4-turbo-preview" "gpt-4-32k" "gpt-4-1106-preview"
                  "gpt-4-0125-preview")
        :curl-args '("-k")))
#+end_src

** Copilot
#+begin_src emacs-lisp
(use-package copilot :pin melpa :ensure t :defer t
  ;;:hook (prog-mode . copilot-mode) ;;actually, I may just want to disable it
  ;;by default.
  :when (executable-find "npm")
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)
              ("C-n" . 'copilot-next-completion)
              ("C-p" . 'copilot-previous-completion)))
#+end_src

The [[https://github.com/chep/copilot-chat.el][copilot-chat.el]]
#+begin_src emacs-lisp
(use-package copilot-chat
  :pin melpa :ensure t :defer t
  :when (executable-find "npm")
  :bind (:map my/llm-keymap
         ("t" . copilot-chat-transient)
         ("d" . copilot-chat-display)
         ("c" . copilot-chat-insert-commit-message))
  ;; :config
  ;; (setq copilot-chat-backend 'curl)
  ;; (setq copilot-chat-gpt-4-model "gpt-4o")
  ;; (setq copilot-chat-gpt-4-key my/llm-openai-key)
  ;; (setq copilot-chat-gpt-4-proxy (my/has-or-get-proxy))
  )
#+end_src

* Miscellaneous
** Common helpers
*** OpenWith
[[https://github.com/garberw/openwith][openwith]] to open external program for file types.
#+begin_src emacs-lisp
(use-package openwith
  :vc (:fetcher github :repo "garberw/openwith" :rev "master")
  :init (openwith-mode 1)
  :config (setq openwith-associations '(("\\.pdf\\'" "sioyek" (file)))))  
#+end_src
*** Which Key

#+begin_src emacs-lisp
(use-package which-key :ensure t
  :diminish which-key-mode
  :hook ((prog-mode text-mode outline-mode) . which-key-mode))
#+end_src
*** pdf tools
pdftools _disabled_
#+begin_src emacs-lisp
;; pdf-tools, only run this on windows
(use-package pdf-tools
  :if (eq system-type 'windows-nt)
  :disabled
  :defer t
  :pin manual
  :magic ("%PDF" . pdf-view-mode)
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-width)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  :custom
  (pdf-annot-activate-created-annotations t "automatically annotate highlights"))
  
#+end_src

** News letter
we configure Emacs with [[https://github.com/skeeto/elfeed][elfeed]] to read the news.
#+begin_src emacs-lisp
  (use-package elfeed :ensure t :defer t
    :config (elfeed-set-max-connections 32))
#+end_src
Here are some of the key bindings for elfeed:

- RET :: view selected entry in a buffer
- b ::  open selected entries in your browser (browse-url)
- y ::  copy selected entries URL to the clipboard
- r ::  mark selected entries as read
- u ::  mark selected entries as unread
- g :: ~elfeed-update-force~ updating the feeds after _modified_ "elfeed.org"
- s :: search/filter, however it *also* sort the feed by source.
- + ::  add a specific tag to selected entries
- - ::  remove a specific tag from selected entries

We load elfeed-org and elfeed-goodies as well.
#+begin_src emacs-lisp
  (use-package elfeed-org
    :when (file-exists-p (expand-file-name "elfeed.org" org-directory))
    :ensure t
    :after elfeed
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files
          (list
           (expand-file-name "elfeed.org" org-directory))))
#+end_src
The elfeed goodies sort the feed based alphabetically, and reorder the layout
#+begin_src emacs-lisp
  (use-package elfeed-goodies
    :ensure t
    :after elfeed
    :config
    (elfeed-goodies/setup))
#+end_src

I would like to open feed buffer using  [[https://github.com/fritzgrabo/elfeed-webkit][elfeed-webkit]] but my Emacs does not support xWidgets.

